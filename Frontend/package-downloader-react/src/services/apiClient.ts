//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.4.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import { notificationStore } from "../stores/NotificationStore";
import { cloneObject } from "../utils/objectsTools";
import { compareVersions } from "../utils/versionsComparer.ts";
import axios, { AxiosInstance, AxiosResponse } from 'axios';

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class PackagesAPIClient {
    private http: AxiosInstance;
    private readonly baseUrl: string;

    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ?? "";
        this.http = axios.create({
            baseURL: this.baseUrl,
        });
    }

    /**
     * @param packageType (optional)
     * @param namePart (optional)
     * @return Success
     */
    getSearchResults = async (packageType: PackageType | undefined, namePart: string | undefined): Promise<PackageInfo[]> => {
        const params = new URLSearchParams();
        if (packageType) params.append('packageType', packageType);
        if (namePart) params.append('namePart', namePart);

        const response: AxiosResponse<IPackageInfo[]> = await this.http.get("/api/PackageInfo/GetSearchResults", { params });
        return response.data.map(item => cloneObject(item, new PackageInfo()));
    };

    /**
     * @param packageType (optional)
     * @param namePart (optional)
     * @return Success
     */
    getSearchSuggestions = async (packageType: PackageType | undefined, namePart: string | undefined): Promise<string[]> => {
        const params = new URLSearchParams();
        if (packageType) params.append('packageType', packageType);
        if (namePart) params.append('namePart', namePart);

        const response: AxiosResponse<string[]> = await this.http.get("/api/PackageInfo/GetSearchSuggestions", { params });
        return response.data;
    };

    /**
     * @param body (optional)
     * @return Success
     */
    preparePackagesDownloadLink = async (body: PackageRequest | undefined): Promise<string> => {
        const response: AxiosResponse<string> = await this.http.post("/api/Packages/PreparePackagesDownloadLink", body);
        const link = response.data;
        const isFullUrl = link.startsWith('http');
        if (!isFullUrl)
            return link;

        const downloadLinkUrl = new URL(link);

        const isLocalHost = ["127.0.0.1", "localhost"].includes(downloadLinkUrl.hostname);
        if (!isLocalHost && downloadLinkUrl.protocol === "http:") {
            downloadLinkUrl.protocol = "https:";
        }

        return downloadLinkUrl.toString();
    };

    /**
     * @param packageType (optional)
     * @param userPrompt (optional)
     * @return Success
     */
    getRecommendations = async (packageType: PackageType | undefined, userPrompt: string | undefined, langCode: string | undefined): Promise<PackageRecommendation[]> => {
        const params = new URLSearchParams();
        if (packageType) params.append('packageType', packageType);
        if (userPrompt) params.append('userPrompt', userPrompt);
        if (langCode) params.append('langCode', langCode);

        const response: AxiosResponse<PackageRecommendation[]> = await this.http.get("/api/Recommendations/GetRecommendations", { params });
        return response.data;
    };
}

export interface PackageDetails {
    packageID: string;
    packageVersion: string;
    packageIconUrl: string;
}

export interface IPackageInfo {
    id: string;
    currentVersion: string;
    otherVersions: string[];
    description: string;
    tags: string[];
    authorInfo: string;
    repositoryUrl: string | null;
    iconUrl: string | null;
    packageUrl: string | null;
    downloadsCount: number;
    isAddedInCart: boolean;
    getPackageIconOrStockImage(): string;
}

export class PackageInfo implements IPackageInfo {
    id!: string;
    currentVersion!: string;
    otherVersions!: string[];
    description!: string;
    tags!: string[];
    authorInfo!: string;
    repositoryUrl!: string | null;
    iconUrl!: string | null;
    packageUrl!: string | null;
    downloadsCount!: number;
    isAddedInCart: boolean = false;
    defaultIcon: string = "/icons/box.svg";
    getPackageIconOrStockImage = () => this.iconUrl ?? this.defaultIcon;
    getLastVersion = () =>
        this.otherVersions?.
        sort((version, versionNext) => compareVersions(version, versionNext, 'DESC'))
            .at(0) ?? this.currentVersion;
}


export interface PackageRecommendation {
    name: string;
    id: string;
    choiceDescription: string;
    codeExample: string;
}

export interface PackageRequest {
    packageType: PackageType;
    sdkVersion?: string | null;
    packagesDetails: PackageDetails[];
}

export enum PackageType {
    Npm = "Npm",
    Nuget = "Nuget",
    VsCode = "VsCode",
    Docker = "Docker"
}

interface ApiHeartbeat {
    isAlive: boolean;
}

const HEARTBEAT_ENDPOINT = '/api/Heartbeat/HeartbeatExists';

export async function isHeartbeatExists(baseUrl: string) {
    try {
        const response: AxiosResponse<ApiHeartbeat> = await axios.get(baseUrl + HEARTBEAT_ENDPOINT);
        return response.data.isAlive;
    }
    catch (error) {
        return false;
    }
}

async function getApiUrl(): Promise<string> {

    const FRONTEND_PORT_DEV = '5094';
    const BACKEND_PORT_DEV = '5093';

    let UrlMain = location.origin;
    
    // Special case for dev server
    if (UrlMain === 'https://dev-front.azerqtech.pw') {
        return 'https://dev-api.azerqtech.pw';
    }
    
    let UrlDev = UrlMain.replace(FRONTEND_PORT_DEV, BACKEND_PORT_DEV);

    let UrlBaseVariants = [UrlMain, UrlDev];

    for (const urlVariant of UrlBaseVariants) {
        if (await isHeartbeatExists(urlVariant)) {
            return urlVariant;
        }
    }

    throw new Error("API server not found!");
}

let apiClient: PackagesAPIClient | undefined = undefined;

export const getPackageApiClient = async () => {

    try {
        if (!apiClient) {
            apiClient = new PackagesAPIClient(await getApiUrl());
        }
        return apiClient;
    } catch (error: any) {
        notificationStore.addError(error.toString());
        throw error;
    }
};